import os
from os import listdir
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
#f = open('./classes.dex', 'rb')
fixed_size = 50176 #224*224

def extract_data(f, target): #data section의 target값을 4바이트 가져옵니다.
    f.seek(target, 0)
    hex_value = f.read(4).hex()
    #print("data_size 의 16진수값 = ", hex_value)
    int_value = int(hex_value[6:8] + hex_value[4:6] + hex_value[2:4] + hex_value[0:2], 16)
    return int_value

def get_data(f, data_off, data_size, option): #data section의 data를 가져옵니다.
    if option is 'string':
        f.seek(data_off, 0)
        data = f.read(data_size).hex() #read to string
    elif option is 'byte':
        f.seek(data_off, 0)
        data = f.read(data_size)  # read to byte
    return data

def str2uint8(data): #hex로 되어 있던 값을 int로 바꿔줍니다.
    uint8_data = list()
    for i in range(len(data)):
        uint8_data.append(int(str(data[i])))

    uint8_data = np.asarray(uint8_data, dtype="int32")
    uint8_data = np.uint8(uint8_data)

    return uint8_data

def pixel2img(pixel, width): #pixel을 이미지로 바꿔줍니다.
    extra = width ** 2
    img = pixel[0:extra]
    pixel = np.reshape(img, [width, width])
    img = Image.fromarray(pixel)
    img = img.resize((224, 224), Image.ANTIALIAS)
    return img

def pixel2bin_img(pixel, width, cpoint): #pixel을 이미지로 바꿔줍니다. cpoint는 임계값
    extra = width ** 2
    img = pixel[0:extra]
    pixel = np.reshape(img, [width, width])

    img = Image.fromarray(pixel)#pixel to image
    img = img.resize((224, 224),Image.ANTIALIAS)  # NEAREST, BILINEAR, BICUBIC, LANCZOS, BOX, HAMMING. base option is resample=NEAREST

    #image to pixel  이렇게 귀찮게 하는 이유는 resize 과정에서 nearest로 보간을 해줘서임. resize 때문에 발생하는 문제임.
    pixel = np.asarray(img, dtype="int32")

    for i in range(224):#임계값보다 작으면 0, 크면 255로 만들어줍니다.
        for j in range(224):
            if pixel[i][j] > cpoint:
                pixel[i][j] = 255
            else:
                pixel[i][j] = 0

    img = Image.fromarray(pixel)#pixel to image
    img = img.resize((224, 224),Image.ANTIALIAS)  # NEAREST, BILINEAR, BICUBIC, LANCZOS, BOX, HAMMING. base option is resample=NEAREST
    return img

def pixel2lc_img(pixel, width): #pixel을 이미지로 바꿔줍니다. resize시의 손실을 줄여줄겁니다.
    extra = width ** 2
    img = pixel[0:extra]

    resized_img = [0 for i in range(fixed_size)] #224 * 224의 배열 생성

    #얼마나 resize되는지 판단해줘야 합니다.
    resize_ratio = int(extra / fixed_size)

    for i in range(fixed_size):#224*224, resized_img에 실제 이미지 압축해서 넣어줄 겁니다.
        box = 0

        for j in range(resize_ratio):#비손실 압축
            if(img[(i*resize_ratio)+j] != 0):#빈도 누적
                box+=1

        r_pixel = int((box*255)/resize_ratio) #정규화 과정
        resized_img[i] = r_pixel

    img = np.reshape(resized_img, [224, 224])

    img = Image.fromarray(img)#pixel to image
    return img

def pixel2graph(pixel, width, count, dex_path, dex_folder):
    extra = width ** 2
    img = pixel[0:extra]
    pixel = np.reshape(img, [width, width])
    img = Image.fromarray(pixel)
    img = img.resize((224, 224), Image.ANTIALIAS)
    x_test = np.asarray(img, dtype="int32")
    x_test = x_test.reshape(-1)
    y_test = list()
    for i in range(224*224):
        y_test.append(i)
    y_test = np.asarray(y_test)
    plt.plot(y_test, x_test, 'b')
    plt.savefig(os.path.join(dex_path, dex_folder, str(count) + ".jpg"))
    plt.close()
    return plt
"""
data_size = extract_data(f, 0x68) #data section의 size를 가져옵니다
data_off = extract_data(f, 0x6c) #data section의 offset을 가져옵니다.

data  = get_data(f, data_off, data_size, 'byte') #offset으로부터 size만큼 가져옵니다.

print("data_size = ",data_size)
print("data_off = ", data_off)

pixel = str2uint8(data) #hex값을 int8형태로 가져옵니다.

width  = int(len(pixel)**0.5)
img = pixel2img(pixel, width) #pixel -> img로 바꿔줍니다. width * width을 넘어서는 잉여값은 제거합니다.

img.show("hello")
print(pixel)
"""